#!/usr/bin/env node

/**
 * GitHub PR Generator
 * Automatically creates Pull Requests based on token changes.
 */

const fs = require('fs-extra');
const path = require('path');
const { execSync } = require('child_process');

class PRGenerator {
	constructor(options = {}) {
		const repoInfo = process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/') : [];
		this.owner = options.owner || repoInfo[0] || 'enovaui';
		this.repo = options.repo || repoInfo[1] || 'design-tokens';
		this.baseBranch = options.baseBranch || process.env.GITHUB_BASE_REF || 'develop';
		this.token = process.env.GITHUB_TOKEN;

		if (!this.token) {
			throw new Error('GITHUB_TOKEN environment variable is required.');
		}
	}

	/**
	 * Make GitHub API request
	 */
	async makeGitHubRequest(endpoint, method = 'GET', data = null) {
		const url = `https://api.github.com${endpoint}`;

		const options = {
			method,
			headers: {
				'Authorization': `token ${this.token}`,
				'Accept': 'application/vnd.github.v3+json',
				'User-Agent': 'enovaui-design-tokens-sync-bot'
			}
		};

		if (data) {
			options.headers['Content-Type'] = 'application/json';
			options.body = JSON.stringify(data);
		}

		try {
			const response = await fetch(url, options);

			if (!response.ok) {
				const errorText = await response.text();
				throw new Error(`GitHub API Error: ${response.status} - ${errorText}`);
			}

			return await response.json();
		} catch (error) {
			console.error('GitHub API request failed:', error);
			throw error;
		}
	}

	/**
	 * Analyze changes and generate branch name
	 */
	generateBranchName(changes) {
		const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
		const changeTypes = [];

		if (Object.keys(changes.added).length > 0) changeTypes.push('add');
		if (Object.keys(changes.modified).length > 0) changeTypes.push('update');
		if (Object.keys(changes.removed).length > 0) changeTypes.push('remove');

		const suffix = changeTypes.join('-') || 'sync';
		return `figma-sync/${suffix}-${timestamp}`;
	}

	/**
	 * Generate PR title
	 */
	generatePRTitle(changes) {
		const added = Object.keys(changes.added).length;
		const modified = Object.keys(changes.modified).length;
		const removed = Object.keys(changes.removed).length;

		const parts = [];
		if (added > 0) parts.push(`‚ú® ${added} tokens added`);
		if (modified > 0) parts.push(`üîÑ ${modified} tokens modified`);
		if (removed > 0) parts.push(`üóëÔ∏è ${removed} tokens removed`);

		return `[Figma Sync] ${parts.join(', ')}`;
	}

	/**
	 * Generate PR body
	 */
	generatePRBody(changes, figmaFileUrl = '') {
		const added = Object.keys(changes.added).length;
		const modified = Object.keys(changes.modified).length;
		const removed = Object.keys(changes.removed).length;

		let body = `## üé® Figma Variables Auto Sync\n\n`;

		if (figmaFileUrl) {
			body += `üìÅ **Figma File**: [Link](${figmaFileUrl})\n`;
		}

		body += `üïê **Sync Time**: ${new Date().toLocaleString('en-US')}\n\n`;

		body += `### üìä Change Summary\n\n`;
		body += `| Type | Count |\n`;
		body += `|------|-------|\n`;
		if (added > 0) body += `| ‚ú® Added tokens | ${added} |\n`;
		if (modified > 0) body += `| üîÑ Modified tokens | ${modified} |\n`;
		if (removed > 0) body += `| üóëÔ∏è Removed tokens | ${removed} |\n`;

		// Add detailed changes
		if (added > 0) {
			body += `\n### ‚ú® Added Tokens\n\n`;
			Object.entries(changes.added).forEach(([path, tokens]) => {
				body += `#### ${path}\n`;
				body += this.formatTokensForMarkdown(tokens);
			});
		}

		if (modified > 0) {
			body += `\n### üîÑ Modified Tokens\n\n`;
			Object.entries(changes.modified).forEach(([path, data]) => {
				body += `#### ${path}\n`;
				if (data.before && data.after) {
					body += `**Before**: \`${JSON.stringify(data.before, null, 2)}\`\n`;
					body += `**After**: \`${JSON.stringify(data.after, null, 2)}\`\n\n`;
				}
			});
		}

		if (removed > 0) {
			body += `\n### üóëÔ∏è Removed Tokens\n\n`;
			Object.keys(changes.removed).forEach(path => {
				body += `- ${path}\n`;
			});
		}

		body += `\n### üîç Review Checklist\n\n`;
		body += `- [ ] Verify token values are applied correctly\n`;
		body += `- [ ] Check for impact on existing components\n`;
		body += `- [ ] Ensure platform-specific tokens are generated correctly\n`;
		body += `- [ ] Verify CSS variables are generated correctly\n\n`;

		body += `---\n`;
		body += `ü§ñ This PR was generated by Figma Variables auto-sync.`;

		return body;
	}

	/**
	 * Format tokens for markdown
	 */
	formatTokensForMarkdown(tokens, prefix = '') {
		let markdown = '';

		Object.entries(tokens).forEach(([key, value]) => {
			const fullKey = prefix ? `${prefix}.${key}` : key;

			if (typeof value === 'object' && value !== null && !value.$ref) {
				markdown += this.formatTokensForMarkdown(value, fullKey);
			} else {
				markdown += `- \`${fullKey}\`: \`${JSON.stringify(value)}\`\n`;
			}
		});

		return markdown;
	}

	/**
	 * Create Git branch and commit changes
	 */
	async createBranchAndCommit(branchName, updatedFiles, changes) {
		try {
			// Create new branch
			console.log(`üåø Creating branch: ${branchName}`);
			execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });

			// Stage changed files
			if (updatedFiles.length > 0) {
				console.log(`üìù Staging ${updatedFiles.length} files...`);
				updatedFiles.forEach(file => {
					try {
						execSync(`git add "${file}"`, { stdio: 'inherit' });
					} catch (error) {
						console.warn(`Failed to add file: ${file}`, error.message);
					}
				});
			}

			// Generate commit message
			const added = Object.keys(changes.added).length;
			const modified = Object.keys(changes.modified).length;
			const removed = Object.keys(changes.removed).length;

			let commitMessage = '[Figma Sync] Auto-update design tokens';
			const details = [];
			if (added > 0) details.push(`${added} added`);
			if (modified > 0) details.push(`${modified} modified`);
			if (removed > 0) details.push(`${removed} removed`);

			if (details.length > 0) {
				commitMessage += `\n\n- ${details.join('\n- ')}`;
			}

			// Commit
			console.log('üíæ Committing changes...');
			execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });

			// Push to remote branch
			console.log('üì§ Pushing to remote repository...');
			execSync(`git push origin ${branchName}`, { stdio: 'inherit' });

			return true;
		} catch (error) {
			console.error('Git operation failed:', error);
			return false;
		}
	}

	/**
	 * Create Pull Request
	 */
	async createPullRequest(branchName, title, body) {
		try {
			const prData = {
				title,
				body,
				head: branchName,
				base: this.baseBranch,
				maintainer_can_modify: true
			};

			console.log('üîÑ Creating Pull Request...');
			const response = await this.makeGitHubRequest(
				`/repos/${this.owner}/${this.repo}/pulls`,
				'POST',
				prData
			);

			return response;
		} catch (error) {
			console.error('Failed to create PR:', error);
			throw error;
		}
	}

	/**
	 * Add labels
	 */
	async addLabels(prNumber, labels = ['design-tokens', 'figma-sync', 'automated']) {
		try {
			await this.makeGitHubRequest(
				`/repos/${this.owner}/${this.repo}/issues/${prNumber}/labels`,
				'POST',
				{ labels }
			);
		} catch (error) {
			console.warn('Failed to add labels:', error);
		}
	}

	/**
	 * Assign reviewers
	 */
	async assignReviewers(prNumber, reviewers = []) {
		if (reviewers.length === 0) return;

		try {
			await this.makeGitHubRequest(
				`/repos/${this.owner}/${this.repo}/pulls/${prNumber}/requested_reviewers`,
				'POST',
				{ reviewers }
			);
		} catch (error) {
			console.warn('Failed to assign reviewers:', error);
		}
	}
}

/**
 * Main execution function
 */
async function main() {
	try {
		console.log('üöÄ Starting PR creation process...');

		// Load change data
		const changesPath = path.join(__dirname, '..', 'figma-changes.json');
		const manifestPath = path.join(__dirname, '..', 'token-update-manifest.json');

		if (!await fs.pathExists(changesPath) || !await fs.pathExists(manifestPath)) {
			console.log('No changes files found. Please run figma-sync.js and token-transformer.js first.');
			return;
		}

		const changesData = await fs.readJson(changesPath);
		const manifestData = await fs.readJson(manifestPath);

		const { changes } = changesData;
		const { updatedFiles } = manifestData;

		// Exit if no changes
		const totalChanges = Object.keys(changes.added).length +
							Object.keys(changes.modified).length +
							Object.keys(changes.removed).length;

		if (totalChanges === 0) {
			console.log('No changes detected. PR will not be created.');
			return;
		}

		const prGenerator = new PRGenerator();

		// Generate branch name and PR content
		const branchName = prGenerator.generateBranchName(changes);
		const title = prGenerator.generatePRTitle(changes);
		const body = prGenerator.generatePRBody(changes, process.env.FIGMA_FILE_URL);

		console.log(`üìã PR Information:`);
		console.log(`- Branch: ${branchName}`);
		console.log(`- Title: ${title}`);
		console.log(`- Changed files: ${updatedFiles.length}`);

		// Create Git branch and commit
		const success = await prGenerator.createBranchAndCommit(branchName, updatedFiles, changes);
		if (!success) {
			console.error('‚ùå Git operations failed.');
			process.exit(1);
		}

		// Create Pull Request
		const pullRequest = await prGenerator.createPullRequest(branchName, title, body);
		console.log(`‚úÖ Pull Request created successfully!`);
		console.log(`üîó URL: ${pullRequest.html_url}`);

		// Add labels and reviewers
		await prGenerator.addLabels(pullRequest.number);

		// Read reviewers from environment variable
		const reviewers = process.env.PR_REVIEWERS ? process.env.PR_REVIEWERS.split(',') : [];
		if (reviewers.length > 0) {
			await prGenerator.assignReviewers(pullRequest.number, reviewers);
			console.log(`üë• Reviewers assigned: ${reviewers.join(', ')}`);
		}

		// Save success information
		const resultPath = path.join(__dirname, '..', 'pr-result.json');
		await fs.writeJson(resultPath, {
			timestamp: new Date().toISOString(),
			success: true,
			pullRequest: {
				number: pullRequest.number,
				url: pullRequest.html_url,
				branch: branchName
			},
			changes: {
				added: Object.keys(changes.added).length,
				modified: Object.keys(changes.modified).length,
				removed: Object.keys(changes.removed).length
			}
		}, { spaces: 2 });

		console.log('üéâ PR creation process completed!');

	} catch (error) {
		console.error('‚ùå Failed to create PR:', error);
		process.exit(1);
	}
}

// Call main function only when script is executed directly
if (require.main === module) {
	main();
}

module.exports = {
	PRGenerator
};
